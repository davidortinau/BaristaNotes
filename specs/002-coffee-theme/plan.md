# Implementation Plan: Coffee-Themed Color System with Theme Selection

**Branch**: `002-coffee-theme` | **Date**: 2025-12-04 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-coffee-theme/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command and defines the technical approach for implementing the coffee-themed color system with user-selectable theme modes.

## Summary

Replace existing generic color palette with a coffee-themed semantic color system that supports light/dark/system theme modes. Update existing `ApplicationTheme.cs` and `AppColors.cs` to use designer-specified coffee colors while preserving MauiReactor theme functionality. Implement theme selection UI in Settings page with immediate application and persistence of user preference across app restarts. Ensure smooth theme transitions and WCAG AA contrast compliance in both modes.

## Technical Context

**Language/Version**: C# 13 / .NET 10  
**Primary Dependencies**: .NET MAUI 10.0, MauiReactor (Theme system), Microsoft.Maui.Graphics (Color APIs), Microsoft.Maui.Essentials (Preferences API for theme persistence)  
**Storage**: MAUI Preferences API for theme mode persistence (key-value storage in platform-specific secure storage)  
**Testing**: xUnit with MAUI test harness for UI testing, manual accessibility testing with screen readers  
**Target Platform**: iOS, Android, macOS Catalyst, Windows (cross-platform mobile + desktop via .NET MAUI)
**Project Type**: Mobile application (MAUI cross-platform)  
**Performance Goals**: Theme switching <300ms, preference persistence <100ms, initial theme load <200ms, system theme detection <500ms  
**Constraints**: WCAG AA contrast (4.5:1 normal text, 3:1 large text), smooth visual transitions without white flashes, memory-efficient color object reuse  
**Scale/Scope**: 6 existing pages (shot logging, activity feed, settings, equipment, beans, user profiles), ~15 semantic color tokens, 3 theme modes, existing ApplicationTheme.cs with ~20 control style definitions

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

All features must demonstrate alignment with constitutional principles:

- [x] **Code Quality Standards**: Design enables single-responsibility color management (semantic tokens centralized in one location), readable color naming (Background, Surface, Primary vs hex codes), and reusable brush objects. No unnecessary complexity—existing MauiReactor Theme class is leveraged rather than reinvented.
- [x] **Test-First Development**: Test scenarios defined in spec acceptance criteria. Will write tests for: theme preference persistence, theme switching logic, system theme detection, color contrast validation. Target 80% coverage for theme service logic, 100% for preference persistence (critical path).
- [x] **User Experience Consistency**: Follows existing MauiReactor theme system patterns (ApplicationTheme.cs OnApply method). WCAG AA contrast requirements explicitly defined in spec (NFR-A1, NFR-A2). Theme selection UI will follow existing settings page patterns. All 6 pages will use consistent semantic color tokens.
- [x] **Performance Requirements**: Performance targets defined in spec (NFR-P1-P4): theme switch <300ms, persistence <100ms, initial load <200ms, system detection <500ms. Theme object caching minimizes allocations. Color lookups are O(1) static property access.

**Violations requiring justification**: None. All constitutional principles are satisfied.

**Post-Phase 1 Re-evaluation**: ✅ PASSED

All constitutional principles remain satisfied after design phase:

- **Code Quality**: `IThemeService` interface has three focused methods (get, set, apply). Single-responsibility maintained—theme mode logic in `ThemeService`, color definitions in `AppColors`, styling application in `ApplicationTheme`. No code duplication—existing `IPreferencesService` reused for persistence.
  
- **Test-First**: Unit test contracts defined in `contracts/theme-contracts.md`. Test coverage targets: 80% for `ThemeService` logic (7 test cases), 100% for preference persistence (integration test), automated contrast validation for all token pairs. Tests can be written before implementation—interfaces and expected behaviors fully specified.
  
- **UX Consistency**: Theme selection UI follows existing Settings page patterns (list of options with visual indicators). All 6 pages use semantic tokens consistently. WCAG AA contrast validated programmatically (4.5:1 for normal text, 3:1 for large text). Smooth transitions ensured by MauiReactor's reactive rendering—no custom animation complexity.
  
- **Performance**: Static readonly color properties (zero allocation). Brush object caching reduces GC pressure. Theme switch is atomic—single `OnApply()` call updates all styles (<300ms target achievable). Preference load is synchronous O(1) key-value lookup (<100ms). No polling—event-driven system theme detection (<500ms response).

**Complexity Justification**: N/A—no violations introduced.

## Project Structure

### Documentation (this feature)

```text
specs/002-coffee-theme/
├── plan.md              # This file (implementation planning)
├── research.md          # Phase 0: Technology decisions and best practices
├── data-model.md        # Phase 1: Theme preference data model
├── quickstart.md        # Phase 1: Getting started guide for developers
├── contracts/           # Phase 1: Theme service interfaces and color contracts
│   └── theme-contracts.md
└── tasks.md             # Phase 2: Implementation task breakdown (created by /speckit.tasks)
```

### Source Code (repository root)

```text
BaristaNotes/                    # Main MAUI application project
├── Resources/
│   └── Styles/
│       ├── AppColors.cs         # EXISTING - Will be updated with coffee palette
│       ├── ApplicationTheme.cs  # EXISTING - Will be updated to use coffee colors
│       ├── AppFontSizes.cs      # EXISTING - No changes needed
│       ├── AppSpacing.cs        # EXISTING - No changes needed
│       └── AppIcons.cs          # EXISTING - No changes needed
├── Pages/
│   ├── SettingsPage.cs          # EXISTING - Will add theme selection UI
│   ├── ShotLoggingPage.cs       # EXISTING - Will verify coffee colors applied
│   ├── ActivityFeedPage.cs      # EXISTING - Will verify coffee colors applied
│   ├── EquipmentManagementPage.cs   # EXISTING - Will verify coffee colors applied
│   ├── BeanManagementPage.cs    # EXISTING - Will verify coffee colors applied
│   └── UserProfileManagementPage.cs # EXISTING - Will verify coffee colors applied
├── Services/
│   ├── IThemeService.cs         # NEW - Theme management interface
│   └── ThemeService.cs          # NEW - Theme mode persistence and application
├── MauiProgram.cs               # EXISTING - Register ThemeService in DI

BaristaNotes.Core/               # Shared core library
└── Services/
    └── IPreferencesService.cs   # EXISTING - Used by ThemeService for persistence

BaristaNotes.Tests/              # Test project
├── Unit/
│   └── Services/
│       ├── ThemeServiceTests.cs # NEW - Unit tests for theme service
│       └── ColorContrastTests.cs # NEW - WCAG AA validation tests
└── Integration/
    └── ThemeIntegrationTests.cs # NEW - End-to-end theme switching tests
```

**Structure Decision**: Mobile + Core library structure (Option 3 from template). MAUI application in `BaristaNotes/` with shared services in `BaristaNotes.Core/`. Theme-related UI code (ApplicationTheme.cs, SettingsPage.cs) lives in main app project, while preference persistence interface is in Core for cross-cutting concerns. This separation allows theme logic to be tested independently of UI.

**Key Files to Update**:
- **AppColors.cs**: Replace existing colors with coffee-themed semantic tokens (Background, Surface, SurfaceVariant, etc.)
- **ApplicationTheme.cs**: Update OnApply() method to use new coffee colors from AppColors instead of hardcoded purple/gray palette
- **SettingsPage.cs**: Add theme selection UI section with Light/Dark/System options
- **ThemeService.cs** (NEW): Encapsulate theme mode logic, preference persistence, and system theme detection

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**Status**: No violations. All constitutional principles are satisfied without exceptions.

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| N/A | N/A | N/A |

---

## Phase 0: Research & Technology Decisions

### Research Tasks

1. **MauiReactor Theme System Integration**
   - **Question**: How does MauiReactor's `Theme` base class and `OnApply()` method work? How does `IsLightTheme` property detect current theme?
   - **Decision**: MauiReactor Theme uses `Application.Current.RequestedTheme` to populate `IsLightTheme` boolean. `OnApply()` is called when theme changes, allowing conditional style application.
   - **Rationale**: Existing ApplicationTheme.cs already uses this pattern extensively. We extend it rather than replace it.
   - **Alternatives Considered**: Custom theme manager bypassing MauiReactor's system—rejected because it duplicates framework functionality and breaks existing style definitions.

2. **MAUI Theme Change Detection**
   - **Question**: How do we detect when device system theme changes at runtime to update "System" theme mode?
   - **Decision**: Subscribe to `Application.Current.RequestedThemeChanged` event to detect OS-level theme changes when "System" mode is active.
   - **Rationale**: Native MAUI event provides reliable, platform-agnostic theme change notifications without polling.
   - **Alternatives Considered**: Platform-specific theme listeners (iOS UITraitCollection, Android Configuration)—rejected because MAUI already abstracts this cross-platform.

3. **Color Contrast Validation**
   - **Question**: How do we programmatically verify WCAG AA contrast ratios (4.5:1 for normal text, 3:1 for large text)?
   - **Decision**: Implement contrast calculator using relative luminance formula from WCAG 2.1 specification: `(L1 + 0.05) / (L2 + 0.05)` where L is relative luminance.
   - **Rationale**: Formula is standardized, deterministic, and can be unit tested. Relative luminance calculated from RGB using: `0.2126 * R + 0.7152 * G + 0.0722 * B` after gamma correction.
   - **Alternatives Considered**: Manual testing only—rejected because automated validation in unit tests prevents regressions when colors change.

4. **Theme Preference Storage**
   - **Question**: Where and how should theme preference be stored for cross-session persistence?
   - **Decision**: Use MAUI `Preferences` API with key "AppThemeMode" storing enum value as string ("Light", "Dark", "System").
   - **Rationale**: MAUI Preferences API is platform-agnostic, secure (iOS Keychain, Android SharedPreferences with encryption), and already used in project (IPreferencesService exists in Core).
   - **Alternatives Considered**: 
     - SQLite database—rejected as overkill for single key-value pair
     - File storage—rejected because Preferences API handles platform-specific secure storage better

5. **Smooth Theme Transition Animation**
   - **Question**: How do we achieve smooth color transitions without white flashes when theme changes?
   - **Decision**: MauiReactor's reactive rendering automatically animates property changes. Ensure `OnApply()` updates all style properties atomically in single render pass.
   - **Rationale**: MauiReactor's component diffing handles smooth transitions. Key is avoiding partial state where some controls are styled and others aren't.
   - **Alternatives Considered**: 
     - Custom fade animations for each control—rejected as too complex and error-prone
     - Delay rendering until all colors computed—rejected because causes visible lag

6. **Coffee Color Palette Implementation**
   - **Question**: Should coffee colors be static properties, dependency-injected services, or resource dictionaries?
   - **Decision**: Static readonly properties in `AppColors.Light` and `AppColors.Dark` nested classes. `ApplicationTheme` queries these based on `IsLightTheme`.
   - **Rationale**: Matches existing `AppColors.cs` structure, zero runtime overhead, compile-time safety, IDE autocomplete support.
   - **Alternatives Considered**:
     - XAML ResourceDictionary—rejected because MauiReactor uses C# styling, not XAML
     - Dependency injection—rejected as overkill for immutable color constants

### Best Practices

1. **Semantic Color Naming**
   - Use intent-based names (Background, Surface, Primary) rather than visual descriptions (LightBrown, DarkCream)
   - Facilitates future theme changes without renaming throughout codebase

2. **Color Token Centralization**
   - All color definitions in single file (`AppColors.cs`)
   - No hardcoded hex values in UI components
   - Brushes created from colors in `ApplicationTheme` for reuse

3. **Performance Optimization**
   - Static color objects initialized once at startup
   - Brush objects cached in ApplicationTheme static properties
   - Theme switching reuses existing objects rather than allocating new ones

4. **Accessibility Testing**
   - Automated unit tests for contrast ratios
   - Manual testing with iOS VoiceOver and Android TalkBack
   - Test theme changes while screen reader active to verify announcements

### Dependencies & Integration Points

- **MauiReactor Theme System**: Extend existing `ApplicationTheme : Theme` class
- **MAUI Preferences API**: Use existing `IPreferencesService` wrapper from Core
- **Application.RequestedThemeChanged**: Subscribe to OS theme changes for System mode
- **Existing Pages**: Update 6 pages to verify coffee colors render correctly (no code changes needed if semantic tokens used properly)

---

## Phase 1: Design & Contracts

### Data Model (data-model.md)

**ThemeMode Enum**
- Values: Light, Dark, System
- Default: System (respects user's OS preference)
- Stored in Preferences as string

**ThemePreference**
- Single preference key-value pair
- Key: "AppThemeMode"
- Value: ThemeMode enum serialized to string
- Persistence: MAUI Preferences API (platform-specific secure storage)

**Color Palette Structure**
- Semantic tokens organized by purpose (background, surface, text, etc.)
- Light/Dark variants for each token
- Brush objects for common colors to reduce allocations

### Contracts (contracts/theme-contracts.md)

**IThemeService Interface**
```csharp
public interface IThemeService
{
    ThemeMode CurrentMode { get; }
    AppTheme CurrentTheme { get; } // Light or Dark (resolved from System if needed)
    
    Task<ThemeMode> GetThemeModeAsync();
    Task SetThemeModeAsync(ThemeMode mode);
    void ApplyTheme();
}
```

**Color Contracts**
- AppColors.Light: Background, Surface, SurfaceVariant, SurfaceElevated, Primary, OnPrimary, TextPrimary, TextSecondary, TextMuted, Outline
- AppColors.Dark: Same tokens as Light with dark mode values
- Semantic colors: Success, Warning, Error, Info (same in both themes)

### Quickstart Guide (quickstart.md)

**For Developers Adding New Pages**:
1. Use `AppColors.Light` and `AppColors.Dark` static properties instead of hardcoded colors
2. Access theme-aware colors via `ApplicationTheme.IsLightTheme ? AppColors.Light.Background : AppColors.Dark.Background`
3. Or better: reference `ApplicationTheme` static properties that handle theme logic automatically
4. Never hardcode hex values in page components

**For Designers**:
- Coffee color palette defined in `BaristaNotes/Resources/Styles/AppColors.cs`
- Semantic token names map to design system concepts
- Update colors by changing hex values in AppColors.cs—theme system propagates changes automatically

---

## Next Steps

1. ✅ Phase 0 complete: Research documented above
2. ⏭️ Create `research.md` from Phase 0 findings
3. ⏭️ Create `data-model.md` with ThemeMode/ThemePreference details
4. ⏭️ Create `contracts/theme-contracts.md` with IThemeService interface
5. ⏭️ Create `quickstart.md` with developer/designer guidance
6. ⏭️ Update agent context with coffee theme technology decisions
7. ⏭️ Re-evaluate Constitution Check after design phase
8. ⏭️ Command ends (tasks.md generation is separate `/speckit.tasks` command)
